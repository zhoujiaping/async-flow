## 背景
系统中有各种业务，业务设计之初，需求并不复杂，业务流程简单的同步执行即可。

随着需求越来越多样化，出现了一些技术需求。

对业务流程，需要
* 支持流程断点继续执行
* 支持延迟执行
* 支持节点定时重试

在技术选型时，考虑了流程引擎camunda，flowable等。

大多数同事认为流程引擎过重。

但是又非常需要一种一致的异步流程执行方案。

结合系统中的现有业务，本项目实现了一种轻量级异步执行方案。

## 基本思想
使用延时消息队列，在需要异步执行某流程节点的时候，向延迟消息队列发送延迟消息。

系统监听到延迟消息，继续执行之前的流程。

## 问题
* 消息重发：使用分布式锁+事务+校验。
* 消息丢失：使用轮询处理超时较久的任务。

发送消息到消息队列之前，向数据库保存任务。执行任务之后，更新任务状态。

## 为了简化实现，约定
* 每个流程对应一个bean，每个节点对应一个方法。
* 节点方法都以String msg,Map extra作为参数。
* 每个节点执行之后，手动推进流程（调用BeanTaskExecutor#async的方法）。
* msg为节点的业务入参，extra为控制流程的参数。

流程定义，实际上相当于在代码中定义了（要改流程，需要改代码）。


## 框架整合
本项目只是一个demo，没有集成spring，mq。

AppContext用来模拟spring上下文。

MQProducer,MQConsumer用来模拟延时队列生产者和消费者。

## 其他思路
* 事件总线
* 状态机
* pipline
* 使用spring stream




